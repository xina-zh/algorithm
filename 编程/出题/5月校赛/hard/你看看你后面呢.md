你看看你后面
你再看看你后面
那你看看你后面
那你再看看你的后面吧
那你看看你的后面呀
好好的看看你的后面吧
那你再看看你的后面呀
什，什么

小黄最近迷上了一款战棋，战棋的地图是一个$n$个点$m$条边的有向图。战棋有$c$种颜色的棋子， 每种颜色棋子有独立的攻击距离$k_i$，棋子只能攻击颜色相同的棋子。
如果一个棋子不能被攻击到，那么小黄认为这个棋子是安全的，现在他布置了一张战棋地图，想考考你有多少棋子是安全的。

输入描述：
第一行两个整数 $n$,$m$,$c$ 表示战棋的点数,边数和颜色数 ($1≤n,k≤10^5$,$0≤m≤10^5$,$1≤c≤30$)
第二行$n$个整数$c_i$表示每个战棋的颜色 （$1≤c_i≤c$)
第二行$c$个整数$k_i$表示每个颜色战棋的攻击距离（$1≤k_i≤10^9$)
接下来$m$行每行三个整数 $u_j$,$v_j$,$d_j$ 表示有一条从$u$到$v$长度为$d$的边 ($1≤u_j,v_j≤n$,$1≤d_j≤1$)

输出描述:
输出一个整数，表示有多少棋子是安全的


 题目分析
我们需要统计每个棋子是否无法被同颜色棋子攻击到。攻击条件为：存在一条从某个同色棋子出发的路径，其总长度 ≤ 该颜色的攻击距离。安全棋子需满足无法被任何同色棋子通过路径攻击。


颜色分组，将节点按颜色分类，统计每种颜色对应的所有节点集合。
对每种颜色$c$初始化：将所有颜色为$c$的节点加入队列作为源点，并标记。
每次更新到达的其他点同时打上源点的标记，如果一个点被不同的源点更新两次则不在进行更新。
记录当前颜色节点前后两次距离之差，即是受到最近的攻击距离。

为什么一个点要更新两次？
由于是有向图，防止$u_1 -> v_1$ 更新后$u_2 -> v_1 ->u_1$不被更新，所以一个点要至少更新两次
由于 BFS 按距离递增处理，后续路径的距离必然 ≥ 前两次的距离，不存在更短值。
时间复杂度为 `O(c*(n + m))`，其中 `c` 是颜色种类数。
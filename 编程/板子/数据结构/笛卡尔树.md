**[笛卡尔树](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91&zhida_source=entity)**（Cartesian Tree）是一种特殊的二叉树，它可以从一个给定的序列构建而成，并且同时满足以下两个性质：

1. **[二叉搜索树](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&zhida_source=entity)（BST）性质**：对于树中的每一个节点，其左子树中的所有节点的值都小于该节点的值；其右子树中的所有节点的值都大于该节点的值。这保证了树在中序遍历时会按照输入序列的顺序访问元素。
2. **[堆性质](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E5%A0%86%E6%80%A7%E8%B4%A8&zhida_source=entity)**：如果我们将笛卡尔树看作是一个最大堆或最小堆，则对于每个节点来说，它的值要么不小于（最大堆）或者不大于（最小堆）其子节点的值。具体采用哪种堆取决于应用场景。
```c++
for(int i=1;i<=n;i++){

        int k=top;

        while(k>0&&a[sta[k]]>a[i]) k--;

        if(k) rs[sta[k]]=i;

        if(k<top) ls[i]=sta[k+1];

        sta[++k]=i;

        top=k;

    }
```
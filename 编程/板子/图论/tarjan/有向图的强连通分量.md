### tarjan

#### 有向图的强连通分量

这份代码实质上实在进行强连通分量缩点，缩点之后为有向无环图
ans[1] ~ ans[num] 存所有的强联通分量，单点则单点存放，按照从小到大的顺序

~~~c++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
#define int long long
typedef pair<int, int> pii;
typedef pair<pii,int> piii;
const int mod = 998244353;
const int inf = 1e18 + 7;
const int N = 2e4 + 10,M=2e5+10;
// #define l first
// #define r second
int n,m;
vector<int> adj[N];
int low[N],dfn[N],cnt;
vector<int> ans[N];
int num;
int sta[N],top;
int st[N];
void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    st[u]=1;
    sta[++top]=u;
    for(int j:adj[u]){
        if(!dfn[j]){
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(st[j]){
            low[u]=min(low[u],low[j]);
        }
    }
    if(dfn[u]==low[u]){
        num++;
        while(1){
            int to=sta[top];
            ans[num].push_back(to);
            top--;
            st[to]=false;
            if(to==u) break;
        }
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int a,b;cin>>a>>b;
        adj[a].push_back(b);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
    for(int i=1;i<=num;i++){
        sort(ans[i].begin(),ans[i].end());
    }
    sort(ans+1,ans+1+num);
    cout<<num<<'\n';
    for(int i=1;i<=n;i++){
        for(int j:ans[i]){
            cout<<j<<" ";
        }
        cout<<'\n';
    }
    return 0;
}
```
~~~


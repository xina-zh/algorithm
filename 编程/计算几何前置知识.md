1. 前置知识点
    (1) pi = acos(-1);
    (2) 余弦定理 c^2 = a^2 + b^2 - 2abcos(t)

2. 浮点数的比较
const double eps = 1e-8;
int sign(double x)  // 符号函数
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int cmp(double x, double y)  // 比较函数
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

3. 向量
    3.1 向量的加减法和数乘运算
    3.2 内积（点积） A·B = |A||B|cos(C)
        (1) 几何意义：向量A在向量B上的投影与B的长度的乘积。
        (2) 代码实现
        double dot(Point a, Point b)
        {
            return a.x * b.x + a.y * b.y;
        }
    3.3 外积（叉积） AxB = |A||B|sin(C)
        (1) 几何意义：向量A与B张成的平行四边形的有向面积。B在A的逆时针方向为正。
        (2) 代码实现
        double cross(Point a, Point b)
        {
            return a.x * b.y - b.x * a.y;
        }
    3.4 常用函数
        3.4.1 取模
        double get_length(Point a)
        {
            return sqrt(dot(a, a));
        }
        3.4.2 计算向量夹角
        double get_angle(Point a, Point b)
        {
            return acos(dot(a, b) / get_length(a) / get_length(b));
        }
        3.4.3 计算两个向量构成的平行四边形有向面积
        double area(Point a, Point b, Point c)
        {
            return cross(b - a, c - a);
        }
        3.4.5 向量A顺时针旋转C的角度：
        Point rotate(Point a, double angle)
        {
            return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle) + a.y * cos(angle));
        }
4. 点与线
    vector 向量
    4.1 直线定理
        (1) 一般式 ax + by + c = 0
        (2) 点向式 p0 + vt
        (3) 斜截式 y = kx + b
    4.2 常用操作
        (1) 判断点在直线上 A x B = 0
        (2) 两直线相交
        // cross(v, w) == 0则两直线平行或者重合
        Point get_line_intersection(Point p, Vector v, Point q, vector w)
        {
            vector u = p - q;
            double t = cross(w, u) / cross(v, w);
            return p + v * t;
        }
        (3) 点到直线的距离
        double distance_to_line(Point p, Point a, Point b)
        {
            vector v1 = b - a, v2 = p - a;
            return fabs(cross(v1, v2) / get_length(v1));
        }
        (4) 点到线段的距离
        double distance_to_segment(Point p, Point a, Point b)
        {
            if (a == b) return get_length(p - a);
            Vector v1 = b - a, v2 = p - a, v3 = p - b;
            if (sign(dot(v1, v2)) < 0) return get_length(v2);
            if (sign(dot(v1, v3)) > 0) return get_length(v3);
            return distance_to_line(p, a, b);
        }
        (5) 点在直线上的投影
        Point get_line_projection(Point p, Point a, Point b)
        {
            Vector v = b - a;
            return a + v * (dot(v, p - a) / dot(v, v));
        }
        (6) 点是否在线段上
        bool on_segment(Point p, Point a, Point b)
        {
            return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <= 0;
        }
        (7) 判断两线段是否相交
        bool segment_intersection(Point a1, Point a2, Point b1, Point b2)
        {
            double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
            double c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
            return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
        }
6. 多边形
    5.1 三角形
    5.1.1 面积
        (1) 叉积
        (2) 海伦公式
            p = (a + b + c) / 2;
            S = sqrt(p(p - a) * (p - b) * (p - c));
    5.1.2 三角形四心
        (1) 外心，外接圆圆心
            三边中垂线交点。到三角形三个顶点的距离相等
        (2) 内心，内切圆圆心
            角平分线交点，到三边距离相等
        (3) 垂心
            三条垂线交点
        (4) 重心
            三条中线交点（到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点）
    5.2 普通多边形
        通常按逆时针存储所有点
        5.2.1 定义
        (1) 多边形
            由在同一平面且不再同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形
        (2) 简单多边形
            简单多边形是除相邻边外其它边不相交的多边形
        (3) 凸多边形
            过多边形的任意一边做一条直线，如果其他各个顶点都在这条直线的同侧，则把这个多边形叫做凸多边形
            任意凸多边形外角和均为360°
            任意凸多边形内角和为(n−2)180°
        5.2.2 常用函数
        (1) 求多边形面积（不一定是凸多边形）
        我们可以从第一个顶点除法把凸多边形分成n − 2个三角形，然后把面积加起来。
        double polygon_area(Point p[], int n)
        {
            double s = 0;
            for (int i = 1; i + 1 < n; i ++ )
                s += cross(p[i] - p[0], p[i + 1] - p[i]);
            return s / 2;
        }
        (2) 判断点是否在多边形内（不一定是凸多边形）
        a. 射线法，从该点任意做一条和所有边都不平行的射线。交点个数为偶数，则在多边形外，为奇数，则在多边形内。
        b. 转角法
        (3) 判断点是否在凸多边形内
        只需判断点是否在所有边的左边（逆时针存储多边形）。
    5.3 皮克定理
        皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为:
            S = a + b/2 - 1
        其中a表示多边形内部的点数，b表示多边形边界上的点数，S表示多边形的面积。
7. 圆
    (1) 圆与直线交点
    (2) 两圆交点
    (3) 点到圆的切线
    (4) 两圆公切线
    (5) 两圆相交面积
    ~~~cpp
    

// 点类/向量类
struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    // 向量加法
    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }
    // 向量减法
    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }
    // 向量数乘
    Point operator * (double k) const { return Point(x * k, y * k); }
    // 向量数除
    Point operator / (double k) const { return Point(x / k, y / k); }
    // 向量点积
    double operator * (const Point& p) const { return x * p.x + y * p.y; }
    // 向量叉积
    double operator ^ (const Point& p) const { return x * p.y - y * p.x; }
    
    // 向量长度
    double length() const { return sqrt(x * x + y * y); }
    // 向量长度的平方
    double length2() const { return x * x + y * y; }
    // 向量标准化
    Point normalize() const { return *this / length(); }
    // 向量旋转（逆时针）
    Point rotate(double angle) const {
        return Point(x * cos(angle) - y * sin(angle), 
                    x * sin(angle) + y * cos(angle));
    }
};

// 直线类
struct Line {
    Point p, v;  // 点向式：p + t*v
    Line(Point p = Point(), Point v = Point()) : p(p), v(v) {}
};

// 圆类
struct Circle {
    Point o;  // 圆心
    double r; // 半径
    Circle(Point o = Point(), double r = 0) : o(o), r(r) {}
};

/**
 * (1) 圆与直线交点
 * @param circle 圆
 * @param line 直线
 * @return 交点向量（0,1或2个交点）
 */
vector<Point> circleLineIntersection(const Circle& circle, const Line& line) {
    vector<Point> intersections;
    
    Point v = line.v.normalize();
    Point p0 = line.p;
    Point p1 = p0 + v;
    
    double a = p1.x - p0.x;
    double b = p0.x - circle.o.x;
    double c = p1.y - p0.y;
    double d = p0.y - circle.o.y;
    
    double A = a * a + c * c;
    double B = 2 * (a * b + c * d);
    double C = b * b + d * d - circle.r * circle.r;
    
    double discriminant = B * B - 4 * A * C;
    
    if (sign(discriminant) < 0) {
        // 无交点
        return intersections;
    }
    
    if (sign(discriminant) == 0) {
        // 一个交点（相切）
        double t = -B / (2 * A);
        intersections.push_back(p0 + v * t);
    } else {
        // 两个交点
        double t1 = (-B + sqrt(discriminant)) / (2 * A);
        double t2 = (-B - sqrt(discriminant)) / (2 * A);
        intersections.push_back(p0 + v * t1);
        intersections.push_back(p0 + v * t2);
    }
    
    return intersections;
}

/**
 * (2) 两圆交点
 * @param c1 圆1
 * @param c2 圆2
 * @return 交点向量（0,1或2个交点）
 */
vector<Point> circleCircleIntersection(const Circle& c1, const Circle& c2) {
    vector<Point> intersections;
    
    Point v = c2.o - c1.o;
    double d = v.length();
    
    // 检查两圆位置关系
    if (sign(d) == 0) {
        // 同心圆
        if (sign(c1.r - c2.r) == 0) {
            // 重合圆，有无数交点，这里返回空
        }
        return intersections;
    }
    
    if (sign(d - (c1.r + c2.r)) > 0 || sign(d - fabs(c1.r - c2.r)) < 0) {
        // 相离或内含
        return intersections;
    }
    
    // 计算交点
    double a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);
    double h = sqrt(c1.r * c1.r - a * a);
    
    Point p2 = c1.o + v.normalize() * a;
    
    // 垂直方向向量
    Point perpendicular(-v.y, v.x);
    Point p3 = p2 + perpendicular.normalize() * h;
    Point p4 = p2 - perpendicular.normalize() * h;
    
    intersections.push_back(p3);
    if (sign(h) != 0) {  // 如果不是相切，添加第二个交点
        intersections.push_back(p4);
    }
    
    return intersections;
}

/**
 * (3) 点到圆的切线
 * @param circle 圆
 * @param p 外部点
 * @return 切线向量（每条切线由两个点表示：切点和外部点）
 */
vector<pair<Point, Point>> pointCircleTangents(const Circle& circle, const Point& p) {
    vector<pair<Point, Point>> tangents;
    
    Point v = p - circle.o;
    double d = v.length();
    
    if (sign(d - circle.r) < 0) {
        // 点在圆内，无切线
        return tangents;
    }
    
    if (sign(d - circle.r) == 0) {
        // 点在圆上，一条切线（垂直于半径）
        Point tangent_dir(-v.y, v.x);
        Point tangent_point = p;
        Point tangent_end = p + tangent_dir;
        tangents.push_back({tangent_point, tangent_end});
        return tangents;
    }
    
    // 点在圆外，两条切线
    double angle = acos(circle.r / d);
    
    // 第一条切线
    Point v1 = v.rotate(-angle).normalize() * circle.r;
    Point tangent_point1 = circle.o + v1;
    tangents.push_back({tangent_point1, p});
    
    // 第二条切线
    Point v2 = v.rotate(angle).normalize() * circle.r;
    Point tangent_point2 = circle.o + v2;
    tangents.push_back({tangent_point2, p});
    
    return tangents;
}

/**
 * (4) 两圆公切线
 * @param c1 圆1
 * @param c2 圆2
 * @return 公切线向量（每条切线由两个点表示：在圆1和圆2上的切点）
 */
vector<pair<Point, Point>> circleCircleTangents(const Circle& c1, const Circle& c2) {
    vector<pair<Point, Point>> tangents;
    
    Point v = c2.o - c1.o;
    double d = v.length();
    double r_diff = fabs(c1.r - c2.r);
    double r_sum = c1.r + c2.r;
    
    if (sign(d) == 0 && sign(c1.r - c2.r) == 0) {
        // 重合圆，无数条公切线，这里返回空
        return tangents;
    }
    
    // 外公切线
    if (sign(d - r_diff) >= 0) {
        if (sign(c1.r - c2.r) == 0) {
            // 等圆的外公切线
            Point dir = Point(-v.y, v.x).normalize();
            Point p1 = c1.o + dir * c1.r;
            Point p2 = c2.o + dir * c2.r;
            tangents.push_back({p1, p2});
            tangents.push_back({c1.o - dir * c1.r, c2.o - dir * c2.r});
        } else {
            // 不等圆的外公切线
            double angle = acos(r_diff / d);
            Point base_v = v.normalize();
            
            // 两条外公切线
            Point dir1 = base_v.rotate(-angle);
            Point dir2 = base_v.rotate(angle);
            
            if (c1.r > c2.r) {
                Point p1 = c1.o + dir1 * c1.r;
                Point p2 = c2.o + dir1 * c2.r;
                tangents.push_back({p1, p2});
                
                p1 = c1.o + dir2 * c1.r;
                p2 = c2.o + dir2 * c2.r;
                tangents.push_back({p1, p2});
            } else {
                Point p1 = c1.o + dir1 * c1.r;
                Point p2 = c2.o + dir1 * c2.r;
                tangents.push_back({p1, p2});
                
                p1 = c1.o + dir2 * c1.r;
                p2 = c2.o + dir2 * c2.r;
                tangents.push_back({p1, p2});
            }
        }
    }
    
    // 内公切线
    if (sign(d - r_sum) >= 0) {
        double angle = acos(r_sum / d);
        Point base_v = v.normalize();
        
        // 两条内公切线
        Point dir1 = base_v.rotate(-angle);
        Point dir2 = base_v.rotate(angle);
        
        Point p1 = c1.o + dir1 * c1.r;
        Point p2 = c2.o - dir1 * c2.r;
        tangents.push_back({p1, p2});
        
        p1 = c1.o + dir2 * c1.r;
        p2 = c2.o - dir2 * c2.r;
        tangents.push_back({p1, p2});
    }
    
    return tangents;
}

/**
 * (5) 两圆相交面积
 * @param c1 圆1
 * @param c2 圆2
 * @return 相交面积
 */
double circleCircleIntersectionArea(const Circle& c1, const Circle& c2) {
    double d = (c1.o - c2.o).length();
    
    // 相离或外切
    if (sign(d - (c1.r + c2.r)) >= 0) {
        return 0.0;
    }
    
    // 内含或内切
    if (sign(d - fabs(c1.r - c2.r)) <= 0) {
        double r = min(c1.r, c2.r);
        return PI * r * r;
    }
    
    // 相交情况
    double angle1 = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
    double angle2 = acos((c2.r * c2.r + d * d - c1.r * c1.r) / (2 * c2.r * d));
    
    double area1 = c1.r * c1.r * angle1 - c1.r * c1.r * sin(2 * angle1) / 2;
    double area2 = c2.r * c2.r * angle2 - c2.r * c2.r * sin(2 * angle2) / 2;
    
    return area1 + area2;
}



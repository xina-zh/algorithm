# 合并的Markdown文档

**合并时间**: 2025-10-15 17:52:46
**源文件数量**: 28

---

## FFT

*文件: FFT.md*

```cpp
#include<iostream>
#include<cmath>
#define int long long
using namespace std;
const double pi=acos(-1);
struct complex{
    double x,y;
    complex(double x=0,double y=0) :x(x),y(y){}

};
complex operator+ (complex a,complex b){
    return {a.x+b.x,a.y+b.y};
}
complex operator- (complex a,complex b){
    return {a.x-b.x,a.y-b.y};
}
complex operator* (complex a,complex b){
    return {a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
}
const int N=3e5+10;
int limit,L=1;
complex a[N],b[N];
int r[N];
void fft(complex *a,int tmp){
    for(int i=0;i<limit;i++){
        if(r[i]>i){
            swap(a[i],a[r[i]]);
        }
    }
    for(int mid=1;mid<limit;mid<<=1){
        complex wn(cos(pi/mid),tmp*sin(pi/mid));
        for(int len=mid<<1,pos=0;pos<limit;pos+=len){
            complex w(1,0);
            for(int k=0;k<mid;k++,w=w*wn){
                complex x=a[k+pos];
                complex y=w*a[k+pos+mid];
                a[pos+k]=x+y;
                a[pos+mid+k]=x-y;
            }
        }
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n,m;cin>>n>>m;
    for(int i=0;i<=n;i++){
        cin>>a[i].x;
    }
    for(int i=0;i<=m;i++){
        cin>>b[i].x;
    }
    while((n+m)>=(1<<L)){
        L++;
    }
    limit=(1<<L);
    for(int i=0;i<limit;i++){
        r[i]=((r[i>>1]>>1)|((i&1)<<(L-1)));
    }
    fft(a,1);
    fft(b,1);
    for(int i=0;i<limit;i++){
        a[i]=a[i]*b[i];
    }
    fft(a,-1);
    for(int i=0;i<=n+m;i++){
        cout<<(int)(a[i].x/limit+0.5)<<' ';
    }
    return 0;
}
```

---

## HLPP

*文件: HLPP.md*


---

## MTT

*文件: MTT.md*

FTT实现速度快，精度差
```cpp
#include <cstdio>
#include <complex>
#define debug(...) fprintf(stderr, __VA_ARGS__)
typedef long long lolong;
typedef std::complex<double> complex;
inline int input() { int x; scanf("%d", &x); return x; }
inline lolong linput() { lolong x; scanf("%lld", &x); return x; }
const int maxn = 400005, maxk = 20;
const complex I(0, 1);
int R[maxn];
complex Wn[maxn];
void FFT(complex *A, int n, int t) {
	if(t == -1)
		for(int i = 1; i < n; i ++)
			if(i < (n - i))
				std::swap(A[i], A[n - i]);
	for(int i = 0; i < n; i ++)
		if(i < R[i])
			std::swap(A[i], A[R[i]]);

	for(int m = 1, l = 0; m < n; m <<= 1, l ++) {
		/* complex Wn(cos(M_PI / m), sin(M_PI / m) * t); */
		for(int i = 0; i < n; i += m << 1) {
			/* complex W = 1; */
			for(int k = i; k < i + m; k ++) {
				/* complex W(cos(M_PI / m * (k - i)), sin(M_PI / m * (k - i)) * t); */
				complex W = Wn[1ll * (k - i) * n / m];
				/* if(t == -1) W = std::conj(W); */
				complex a0 = A[k], a1 = A[k + m] * W;
				A[k] = a0 + a1;
				A[k + m] = a0 - a1;
				/* W *= Wn; */
			}
		}
	}

	if(t == -1)
		for(int i = 0; i < n; i ++)
			A[i] /= n;
}

int mod;
inline lolong num(complex x) {
	double d = x.real();
	return d < 0 ? lolong(d - 0.5) % mod : lolong(d + 0.5) % mod;
}

inline void FFTFFT(complex *a, complex *b, int len, int t) {
	for(int i = 0; i < len; i ++)
		a[i] = a[i] + I * b[i];
	FFT(a, len, t);
	for(int i = 0; i < len; i ++)
		b[i] = std::conj(a[i ? len - i : 0]);
	for(int i = 0; i < len; i ++) {
		complex p = a[i], q = b[i];
		a[i] = (p + q) * 0.5;
		b[i] = (q - p) * 0.5 * I;
	}
}

complex a0[maxn], a1[maxn], b0[maxn], b1[maxn];
/* complex a0b0[maxn], a1b0[maxn], a0b1[maxn], a1b1[maxn]; */
complex p[maxn], q[maxn];

int main() {
	int n = input(), m = input();
	mod = input();
	int M = int(sqrt(mod) + 1);

	for(int i = 0; i <= n; i ++) {
		int x = input() % mod;
		a0[i] = x / M;
		a1[i] = x % M;
	}
	for(int i = 0; i <= m; i ++) {
		int x = input() % mod;
		b0[i] = x / M;
		b1[i] = x % M;
	}
	int len = 1;
	while(len < n + m + 1)
		len <<= 1;

	for(int i = 1; i < len; i ++)
		R[i] = R[i >> 1] >> 1 | ((i & 1) * (len >> 1));

	for(int i = 0; i < len; i ++)
		Wn[i] = complex(cos(M_PI / len * i), sin(M_PI / len * i));

	FFTFFT(a0, a1, len, 1);
	FFTFFT(b0, b1, len, 1);

	for(int i = 0; i < len; i ++) {
		p[i] = a0[i] * b0[i] + I * a1[i] * b0[i];
		q[i] = a0[i] * b1[i] + I * a1[i] * b1[i];
	}

	FFT(p, len, -1);
	FFT(q, len, -1);

	for(int i = 0; i <= n + m; i ++)
		printf("%lld ", (M * M * num(p[i].real()) % mod +
				M * (num(p[i].imag()) + num(q[i].real())) % mod +
				num(q[i].imag())) % mod);
	puts("");
}

```
NTT实现，速度慢精度高
```cpp
#include <bits/stdc++.h>
//#include <bits/extc++.h>
#define N 800005 
#define __BEGIN_MULTITEST__ \
	signed T; \
	scanf("%d",&T); \
	while(T--) \
	{
#define __END_MULTITEST__ }
using namespace std;
//using namespace __gnu_cxx;
//using namespace __gnu_pbds;
namespace FNTT
{
	const long long modA=998244353,modB=1004535809,modC=469762049,G=3,M=1ll*modA*modB;
	long long mod;
	int rev[N];
	long long quick_pow(long long a,long long b,const long long mod)
	{
		int ret=1;
		while(b)
		{
			if(b&1)
				ret=1ll*ret*a%mod;
			a=1ll*a*a%mod;
			b>>=1;
		}
		return ret;
	}
	const long long MA=quick_pow(modB%modA,modA-2,modA),MB=quick_pow(modA%modB,modB-2,modB),MC=quick_pow(M%modC,modC-2,modC);
	long long slow_mul(long long a,long long b,const long long mod)
	{
		long long ret=0;
		while(b)
		{
			if(b&1)
				ret=(ret+a)%mod;
			a=(a<<1)%mod;
			b>>=1;
		}
		return ret;
	}
	void NTTinit(int &lim,int n)
	{
		lim=1;
		int l=-1;
		while(lim<=(n<<1))
		{
			lim<<=1;
			l++;
		}
		for(int i=0;i<lim;i++)	
			rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
	}
	void NTT(int f[],int type,int lim,int mod)
	{
		for(int i=0;i<lim;i++)
			if(i<rev[i])
				swap(f[i],f[rev[i]]);
		for(int k=1;k<lim;k<<=1)
			for(int i=0,w=quick_pow(G,(mod-1)/(k<<1),mod);i<lim;i+=(k<<1))
				for(int j=0,prodw=1;j<k;j++,prodw=1ll*prodw*w%mod)
				{
					int x=f[i|j],y=1ll*f[i|j|k]*prodw%mod;
					f[i|j]=(x+y)%mod;
					f[i|j|k]=(x-y+mod)%mod;
				}
		if(type==-1)
		{
			int tmpinv=quick_pow(lim,mod-2,mod);
			f[0]=1ll*f[0]*tmpinv%mod;
			for(int i=1;i<=(lim>>1);i++)
			{
				f[i]=1ll*f[i]*tmpinv%mod;
				if(i!=lim-i)
					f[lim-i]=1ll*f[lim-i]*tmpinv%mod;
				swap(f[i],f[lim-i]);
			}
		}
	}
	long long CRT(int a,int b,int c)
	{
		long long A=(slow_mul(1ll*modB*a%M,MA,M)+slow_mul(1ll*modA*b%M,MB,M))%M;
		long long k=(c-A%modC+modC)%modC*1ll*MC%modC;
		return (1ll*k%mod*1ll*(M%mod)%mod+A%mod)%mod;
	}
	void mulNTT(const int f[],const int g[],int h[],int mod,int n,int lim)
	{
		static int a[N],b[N];
		memcpy(a,f,sizeof(int)*n);
		memcpy(b,g,sizeof(int)*n);
		memset(a+n,0,sizeof(int)*(lim-n));
		memset(b+n,0,sizeof(int)*(lim-n));
		NTT(a,1,lim,mod);
		NTT(b,1,lim,mod);
		for(int i=0;i<lim;i++)
			h[i]=1ll*a[i]*b[i]%mod;
		NTT(h,-1,lim,mod);
		memset(h+n,0,sizeof(int)*(lim-n));
	}
	void MTT(int f[],int g[],int h[],int n,int m)
	{
		int lim;
		NTTinit(lim,n+m);
		static int tmpa[N],tmpb[N],tmpc[N];
		mulNTT(f,g,tmpa,modA,n+m+1,lim);
		mulNTT(f,g,tmpb,modB,n+m+1,lim);
		mulNTT(f,g,tmpc,modC,n+m+1,lim);
		for(int i=0;i<=n+m;i++)
			h[i]=(CRT(tmpa[i],tmpb[i],tmpc[i])%mod+mod)%mod;
	}
}
using namespace FNTT;
int n,m;
int f[N],g[N],h[N];
signed main()
{
//	__BEGIN_MULTITEST__
	scanf("%d%d%lld",&n,&m,&mod);
	for(int i=0;i<=n;i++)
		scanf("%d",&f[i]);
	for(int i=0;i<=m;i++)
		scanf("%d",&g[i]);
	MTT(f,g,h,n,m);
	for(int i=0;i<=n+m;i++)
		printf("%d ",h[i]);
	printf("\n");
//	__END_MULTITEST__
	return 0;
}

```

---

## MTT多项式乘法逆

*文件: MTT多项式乘法逆.md*

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define ull unsigned long long
#define RG register
#define MAX 444444
#define MOD (1000000007)
const double Pi=acos(-1);
const int m=sqrt(MOD);
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}
struct Complex{double a,b;}W[MAX],A[MAX],B[MAX],C[MAX],D[MAX];
Complex operator+(Complex a,Complex b){return (Complex){a.a+b.a,a.b+b.b};}
Complex operator-(Complex a,Complex b){return (Complex){a.a-b.a,a.b-b.b};}
Complex operator*(Complex a,Complex b){return (Complex){a.a*b.a-a.b*b.b,a.a*b.b+a.b*b.a};}
int r[MAX];
void FFT(Complex *P,int N,int opt)
{
	for(int i=0;i<N;++i)if(i<r[i])swap(P[i],P[r[i]]);
	for(int i=1;i<N;i<<=1)
		for(int p=i<<1,j=0;j<N;j+=p)
			for(int k=0;k<i;++k)
			{
				Complex w=(Complex){W[N/i*k].a,W[N/i*k].b*opt};
				Complex X=P[j+k],Y=P[i+j+k]*w;
				P[j+k]=X+Y;P[i+j+k]=X-Y;
			}
	if(opt==-1)for(int i=0;i<N;++i)P[i].a/=1.0*N;
}
void Multi(int *a,int *b,int len,int *ret)
{
	for(int i=0;i<(len<<1);++i)A[i]=B[i]=C[i]=D[i]=(Complex){0,0};
	for(int i=0;i<len;++i)
	{
		a[i]%=MOD;b[i]%=MOD;
		A[i]=(Complex){(a[i]/m)*1.0,0};
		B[i]=(Complex){(a[i]%m)*1.0,0};
		C[i]=(Complex){(b[i]/m)*1.0,0};
		D[i]=(Complex){(b[i]%m)*1.0,0};
	}
	int N,l=0;
	for(N=1;N<=len;N<<=1)++l;
	for(int i=0;i<N;++i)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=1;i<N;i<<=1)
		for(int k=0;k<i;++k)W[N/i*k]=(Complex){cos(k*Pi/i),sin(k*Pi/i)};
	FFT(A,N,1);FFT(B,N,1);FFT(C,N,1);FFT(D,N,1);
	for(int i=0;i<N;++i)
	{
		Complex tmp=A[i]*C[i];
		C[i]=B[i]*C[i],B[i]=B[i]*D[i],D[i]=D[i]*A[i];
		A[i]=tmp;C[i]=C[i]+D[i];
	}
	FFT(A,N,-1);FFT(B,N,-1);FFT(C,N,-1);
	for(int i=0;i<len;++i)
	{
		ret[i]=0;
		ret[i]=(ret[i]+1ll*(ll)(A[i].a+0.5)%MOD*m%MOD*m%MOD)%MOD;
		ret[i]=(ret[i]+1ll*(ll)(C[i].a+0.5)%MOD*m%MOD)%MOD;
		ret[i]=(ret[i]+1ll*(ll)(B[i].a+0.5)%MOD)%MOD;
		ret[i]=(ret[i]+MOD)%MOD;
	}
}
int c[MAX],d[MAX];
void Inv(int *a,int *b,int len)
{
	if(len==1){b[0]=fpow(a[0],MOD-2);return;}
	Inv(a,b,len>>1);
	Multi(a,b,len,c);
	Multi(c,b,len,d);
	for(int i=0;i<len;++i)b[i]=(b[i]+b[i])%MOD;
	for(int i=0;i<len;++i)b[i]=(b[i]+MOD-d[i])%MOD;
}
int n,a[MAX],b[MAX];
int main()
{
	n=read();int N;
	for(int i=0;i<n;++i)a[i]=read();
	for(N=1;N<n;N<<=1);
	Inv(a,b,N);
	for(int i=0;i<n;++i)printf("%d ",b[i]);
	return 0;
}


```

---

## NTT

*文件: NTT.md*

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#define int long long
using namespace std;
const int MOD = 998244353;
const int G = 3; // 原根
int pow_mod(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}
const int N = 3e5 + 10;
int limit, L = 1;
int a[N], b[N];
int r[N];
void ntt(int *a, int type) {
    for (int i = 0; i < limit; i++) {
        if (r[i] < i) {
            swap(a[i], a[r[i]]);
        }
    }
    for (int mid = 1; mid < limit; mid <<= 1) {
        int wn = pow_mod(G, (MOD - 1) / (mid << 1));
        if (type == -1) wn = pow_mod(wn, MOD - 2);
        for (int len = mid << 1, pos = 0; pos < limit; pos += len) {
            int w = 1;
            for (int k = 0; k < mid; k++, w = w * wn % MOD) {
                int x = a[pos + k];
                int y = w * a[pos + k + mid] % MOD;
                a[pos + k] = (x + y) % MOD;
                a[pos + k + mid] = (x - y + MOD) % MOD;
            }
        }
    }
    if (type == -1) {
        int inv_limit = pow_mod(limit, MOD - 2);
        for (int i = 0; i < limit; i++) {
            a[i] = a[i] * inv_limit % MOD;
        }
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int n, m; cin >> n >> m;
    for (int i = 0; i <= n; i++) {
        cin >> a[i];
        a[i] %= MOD;
    }
    for (int i = 0; i <= m; i++) {
        cin >> b[i];
        b[i] %= MOD;
    }
    while ((1 << L) < n + m + 1) {
        L++;
    }
    limit = (1 << L);
    for (int i = 0; i < limit; i++) {
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));
    }
    ntt(a, 1);
    ntt(b, 1);
    for (int i = 0; i < limit; i++) {
        a[i] = a[i] * b[i] % MOD;
    }
    ntt(a, -1);
    for (int i = 0; i <= n + m; i++) {
        cout << a[i] << ' ';
    }
    return 0;
}
```

---

## NTT求多项式逆，对数函数，指数函数，开根

*文件: NTT求多项式逆，对数函数，指数函数，开根.md*

已知 F(x)，要求 G(x) 令 G(x)≡lnF(x)。
令函数 f(x)=ln(x)，则原式可以化作：
G(x)≡f(F(x)) (mod  xn)
两边求导，发现 f(F(x)) 是个复合函数，复合函数求导公式为 f(g(x))′=f′(g(x))g′(x)，所以左右求导之后为：
G′(x)=f′(F(x))F′(x) (mod  xn)
此时我们可以想一想 ln 的求导公式，ln′(x)=x1​，所以接着可以化为：
G′(x)=F(x)F′(x)​ (mod  xn)

这个时候你可能要问了：诶多项式除法？你在逗我吗？
当然不是辣……我们刚刚才学多项式的逆元，反正我们不要求商只要求余数，为什么不拿出来用呢？
所以我们只需要将读入的 F 求导作为 a，求逆作为 b，计算出 a×b (mod  998244353)，此时求出的是 G′，对它求积分就可以得出我们要求的 G 了。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=998244353;
long long qpow(long long a,long long k){
	long long mulv=1;
	while(k)
	{
		if(k&1)mulv=mulv*a%P;
		a=a*a%P;
		k>>=1;
	}
	return mulv;
}
long long inv(long long x){
	return qpow(x%P,P-2);
}
struct Poly:vector<long long>
{
	Poly(int _n):vector<long long>(_n){}
	void change(){
		vector<int> rev(size());
		for(int i=1;i<size();i++)
			rev[i]=rev[i/2]/2+(i&1)*size()/2;
		for(int i=1;i<size();i++)
			if(rev[i]<i)std::swap((*this)[i],(*this)[rev[i]]);
	}
	//ntt 前数组长度需要变为 2^k
	void NTT(int op){
		change();
		for(int l=2;l<=size();l<<=1){
			int gn=qpow(3,(P-1)/l);
			if(op==-1)gn=inv(gn);
			for(int s=0;s<size();s+=l){
				long long g=1;
				for(int i=0;i<l/2;i++,g=g*gn%P){
					long long L=(*this)[s+i],R=(*this)[s+i+l/2];
					(*this)[s+i]=(L+g*R)%P;
					(*this)[s+i+l/2]=(L+P-g*R%P)%P;
				}
			}
		}
		if(op==-1){
			int tmp=inv(size());
			for(auto &ai:*this)ai=ai*tmp%P;
		}
	}
	void display(string name){
		cout<<name<<endl;
		for(auto ai:*this)
			cout<<ai<<" ";
		cout<<endl;
	}
};
Poly polyInv(Poly &f){
	Poly f_inv(1);
	f_inv[0]=inv(f[0]);
	for(int i=2;i<=f.size();i<<=1){
		f_inv.resize(i);
		int L=i<<1;
		Poly g(L),inv_t(L);
		for(int j=0;j<i;j++){
			g[j]=f[j];
			inv_t[j]=f_inv[j];
		}
		g.NTT(1),inv_t.NTT(1);
		for(int j=0;j<L;j++)
			g[j]=g[j]*inv_t[j]%P*inv_t[j]%P;
		g.NTT(-1);
		for(int j=0;j<i;j++)
			f_inv[j]=(f_inv[j]+f_inv[j]+P-g[j])%P;
	}
	return f_inv;
}
Poly polyDeriv(Poly &f){
	Poly ret(f.size());
	for(int i=0;i<f.size()-1;i++)
		ret[i]=f[i+1]*(i+1)%P;
	return ret;
}
Poly polyInt(Poly &f){
	Poly ret(f.size());
	for(int i=1;i<f.size();i++)
		ret[i]=f[i-1]*inv(i)%P;
	return ret;
}
Poly polyLn(Poly &f){
	auto df=polyDeriv(f);
	auto f_inv=polyInv(f);
	df.resize(f.size()*2);
	f_inv.resize(f.size()*2);
	df.NTT(1);
	f_inv.NTT(1);
	for(int i=0;i<df.size();i++)
		df[i]=df[i]*f_inv[i]%P;
	df.NTT(-1);
	auto ret_int=polyInt(df);
	ret_int.resize(f.size());
	return ret_int;
}
Poly polyExp(Poly &f){
	Poly exp_f(1);
	exp_f[0]=1;
	for(int i=2;i<=f.size()*2;i<<=1){
		auto temp=polyLn(exp_f);
		for(int j=0;j<i/2;j++)
			temp[j]=(f[j]-temp[j]+P)%P;
		temp[0]+=1;
		exp_f.resize(i),temp.resize(i);
		temp.NTT(1),exp_f.NTT(1);
		for(int j=0;j<i;j++)
			exp_f[j]=exp_f[j]*temp[j]%P;
		exp_f.NTT(-1);
	}
	exp_f.resize(f.size());
	return exp_f;
}
Poly polySqrt(Poly &f) {
    Poly g(1);
    g[0] = 1;
    long long inv2 = inv(2);
    for (int len = 2; len <= f.size(); len <<= 1) {
        Poly g0 = g;
        g0.resize(len);
        Poly h = polyInv(g0);
        h.resize(len);
        Poly f_len(len);
        for (int i = 0; i < min(len, (int)f.size()); i++) {
            f_len[i] = f[i];
        }
        f_len.resize(2 * len);
        h.resize(2 * len);
        f_len.NTT(1);
        h.NTT(1);
        for (int i = 0; i < 2 * len; i++) {
            f_len[i] = f_len[i] * h[i] % P;
        }
        f_len.NTT(-1);
        f_len.resize(len);
        for (int i = 0; i < len; i++) {
            g0[i] = (g0[i] + f_len[i]) * inv2 % P;
        }
        g = g0;
    }
    return g;
}

int main()
{
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    int len=1<<(__lg(n)+1);
    Poly a(len);
    for(int i=0;i<n;i++)cin>>a[i];
    auto exp_a=polySqrt(a);
    for(int i=0;i<n;i++)
        cout<<exp_a[i]<<" ";
    return 0;
}

```

---

## dinic

*文件: dinic.md*


```c++
#include<iostream>
#include<queue>
using namespace std;

#define int long long
int n,m,S,T;
const int N=205,M=5005,inf=1e9+7;
int q[N],e[M*2],ne[M*2],w[M*2],idx;
int depth[N];
int now[N];

void add(int a,int b,int c){
    e[idx]=b;w[idx]=c;ne[idx]=q[a];q[a]=idx++;
    e[idx]=a;w[idx]=0;ne[idx]=q[b];q[b]=idx++;
}

bool bfs(){
    for(int i=0;i<=n;i++) depth[i]=inf;
    now[S]=q[S];
    queue<int> que;
    que.push(S);
    depth[S]=1;
    while(que.size()){
        int to=que.front();que.pop();
        for(int i=q[to];i!=-1;i=ne[i]){
            if(!w[i]) continue;
            int j=e[i];
            if(depth[j]!=inf) continue;
            now[j]=q[j];
            que.push(j);
            depth[j]=depth[to]+1;
            if(j==T) return true;
        }
    }
    return false;
}

int dfs(int u,int sum){
    if(u==T) return sum;
    int res=0;
    for(int i=now[u];i!=-1&&res<sum;i=ne[i]){
        now[u]=i;
        if(!w[i]) continue;
        int j=e[i];
        if(depth[j]!=depth[u]+1) continue;
        int k=dfs(j,min(w[i],sum-res));
        if(k==0) depth[j]=inf;
        res+=k;
        w[i]-=k;w[i^1]+=k;
    }
    return res;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m>>S>>T;
    for(int i=0;i<=n;i++) q[i]=-1;
    for(int i=1;i<=m;i++){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int ans=0;
    while(bfs()){
        ans+=dfs(S,inf);
    }
    cout<<ans<<'\n';
    return 0;
}


```

---

## 凸包

*文件: 凸包.md*

```c++
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>

using namespace std;
typedef pair<double,double> pdd;
#define x first
#define y second
const int N=1e5+10;

int sta[N],top;
int used[N];
pdd operator-(pdd a,pdd b){
    return {a.x-b.x,a.y-b.y};
}

double operator*(pdd a,pdd b){
    return a.x*b.y-a.y*b.x;
}
double cross(pdd a,pdd b,pdd c){
    return (b-a)*(c-a);
}
vector<pdd> a;
double jl(pdd a,pdd b){
    double dx=a.x-b.x;
    double dy=a.y-b.y;
    return sqrtl(dx*dx+dy*dy);
}

  

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        double j,k;cin>>j>>k;
        a.push_back({j,k});
    }
    sort(a.begin(),a.end());
    a.erase(unique(a.begin(),a.end()),a.end());
    int len=a.size();
    for(int i=0;i<len;i++){
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0){
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    used[0]=0;
    for(int i=len-2;i>=0;i--){
        if(used[i]) continue;
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0){
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    double ans=0;
    for(int i=2;i<=top;i++){
        ans+=jl(a[sta[i-1]],a[sta[i]]);
    }
    printf("%.2lf",ans);
    return 0;
}

```

---

## 势能费用流

*文件: 势能费用流.md*

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<vector>
#include<fstream>
using namespace std;
#define int long long
int n,m,S,T;
const int inf=1e12+7;
const int N=5e4+10;
const int M=1e6+10;
int q[N],e[M],ne[M],idx,v[M],w[M];
void add(int a,int b,int c,int d){
    e[idx]=b;w[idx]=c;v[idx]=d;ne[idx]=q[a];q[a]=idx++;
    e[idx]=a;w[idx]=0;v[idx]=-d;ne[idx]=q[b];q[b]=idx++;
}
int h[N];
typedef pair<int,int> pii;
int flow,fee;
int info[N];
int pre[N],dist[N];
int vis[N];
void spfa(){
    queue<int> que;
    for(int i=1;i<=n;i++){
        h[i]=inf;
    }
    for(int i=1;i<=n;i++){
        que.push(i);
        vis[i]=1;
    }
    while(que.size()){
        int to=que.front();que.pop();
        vis[to]=0;
        for(int i=q[to];i!=-1;i=ne[i]){
            if(!w[i]) continue;
            int j=e[i];
            if(h[j]>h[to]+v[i]){
                h[j]=h[to]+v[i];
                if(!vis[j]){
                    que.push(j);
                    vis[j]=1;
                }
            }
        }
    }
}
int st[N];
bool dijkstra(){
    for(int i=1;i<=n;i++){
        dist[i]=inf;
        st[i]=0;
        info[i]=0;
    }
    info[S]=inf;
    dist[S]=0;
    priority_queue<pii,vector<pii>,greater<pii>> que;
    que.push({0,S});
    while(que.size()){
        pii to =que.top();que.pop();
        int u=to.second;
        if(st[u]) continue;
        st[u]=1;
        for(int i=q[u];i!=-1;i=ne[i]){
            if(!w[i]) continue;
            int j=e[i];
            int zzz=v[i]+h[u]-h[j];
            if(dist[j]>dist[u]+v[i]+h[u]-h[j]){
                dist[j]=dist[u]+v[i]+h[u]-h[j];
                pre[j]=i;
                que.push({dist[j],j});
                info[j]=min(info[u],w[i]);
            }
        }
    }
    for(int i=1;i<=n;i++){
        dist[i]=dist[i]+h[i]-h[S];
    }
    return info[T]>0;
}
void ek(){
    while(dijkstra()){
        int t=info[T];
        flow+=t;fee+=dist[T]*t;
        for(int i=T;i!=S;i=e[pre[i]^1]){
            w[pre[i]]-=t;
            w[pre[i]^1]+=t;
        }
        for(int i=1;i<=n;i++){
            dist[i]=dist[i]-h[i]+h[S];
            h[i]+=dist[i];
        }
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m>>S>>T;
    for(int i=1;i<=n;i++) q[i]=-1;
    for(int i=1;i<=m;i++){
        int a,b,c,d;cin>>a>>b>>c>>d;
        add(a,b,c,d);
    }
    spfa();
    ek();
    cout<<flow<<' '<<fee;
    return 0;
}
```

---

## 区间dp

*文件: 区间dp.md*

所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）
```
for (int len = 1; len <= n; len++) {         // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点
        int j = i + len - 1;                 // 区间终点
        if (len == 1) {
            dp[i][j] = 初始值
            continue;
        }

        for (int k = i; k < j; k++) {        // 枚举分割点，构造状态转移方程
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
}

```
## 环形dp
我们可以把链延长两倍，变成 2n个堆，其中 i 和 i+n 是相同的两个堆

---

## 后缀数组

*文件: 后缀数组.md*

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1000010;
int n, m; //字符串长度、不同字符数量

char s[N];

//sa[i] 表示排名第 i 的是第几个后缀

//x[i] 表示第 i 个后缀的第一关键字

//y[i] 表示第 i 个后缀的第二关键字

//c[i] 表示关键字为 i 的数的个数

//rk[i] 表示第 i 个后缀的排名

//height[i] 表示排名第 i 的后缀和排名第 i - 1 的后缀的最长公共前缀

int sa[N], x[N], y[N], c[N], rk[N], height[N];

  

void get_sa() //预处理 sa

{

    //将所有后缀按照首字母从小到大排序（基数排序）

    for(int i = 1; i <= n; i++) c[x[i] = s[i]]++; //记录每个关键字出现的次数

    for(int i = 2; i <= m; i++) c[i] += c[i - 1]; //求前缀和

    for(int i = n; i >= 1; i--) sa[c[x[i]]--] = i; //为每个数安排位置

  

    //每一轮将后缀按照前 2k 个字符排序

    for(int k = 1; k <= n; k <<= 1)

    {

        //先将所有后缀按照第二关键字排序

        int num = 0;

        for(int i = n - k + 1; i <= n; i++) y[++num] = i;

        for(int i = 1; i <= n; i++)

            if(sa[i] > k)

                y[++num] = sa[i] - k;

  

        //再将所有后缀按照第一关键字排序（基数排序）

        for(int i = 1; i <= m; i++) c[i] = 0;

        for(int i = 1; i <= n; i++) c[x[i]]++;

        for(int i = 2; i <= m; i++) c[i] += c[i - 1];

        for(int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i], y[i] = 0; //y 数组清空，用于后面存储当前的第一关键字

  

        //将排序后的所有后缀再按照前 2k 个字符离散化

        swap(x, y);

        x[sa[1]] = 1, num = 1;

        for(int i = 2; i <= n; i++)

            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;

  

        if(num == n) break; //如果 n 个后缀的排名都不同，说明已经排好序

        m = num; //更新不同字符的个数

    }

}

  

void get_height() //预处理 height

{

    for(int i = 1; i <= n; i++) rk[sa[i]] = i; //预处理 rk

    //预处理 height

    for(int i = 1, k = 0; i <= n; i++) //k 记录当前的 h[i]

    {

        if(rk[i] == 1) continue; //height[1] 默认为 0

        if(k) k--; //应该从 h[i - 1] - 1 开始枚举，也就是 k - 1

        int j = sa[rk[i] - 1]; //记录第 i 个后缀前一个排名的后缀

        //如果 i 和 j 的第 k 位相同，则最长公共前缀长度 + 1

        while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;

        height[rk[i]] = k; //height[rk[i]] = k

    }

}

  

int main()

{

    scanf("%s", s + 1);

  

    n = strlen(s + 1), m = 122; //最大字符 'z' 的 ASCII 码是 122

    get_sa(); //预处理 sa

    get_height(); //预处理 height

  

    for(int i = 1; i <= n; i++) printf("%d ", sa[i]);

    puts("");

    for(int i = 1; i <= n; i++) printf("%d ", height[i]);

  

    return 0;

}
```

---

## 多源最短路

*文件: 多源最短路.md*

```cpp
#include<iostream>
#include<queue>
#include<cstring>

using namespace std;
#define int long long
const int N=3e3+10,M=6e4+10;
const int inf=1e18+7;
int n,m;
int q[N],w[M],e[M],ne[M],idx;

typedef pair<int,int> pii;

void add(int a,int b,int c){
    e[idx]=b;w[idx]=c;ne[idx]=q[a];q[a]=idx++;
}
int height[N];
int cnt[N];
int st[N];
int dist[N];
int non=1e9;
bool spfa(){
    queue<int> que;
    for(int i=1;i<=n;i++){
        que.push(i);
        st[i]=1;
    }
    while(que.size()){
        int to=que.front();st[to]=0;
        que.pop();
        for(int i=q[to];i!=-1;i=ne[i]){
            int j=e[i];
            if(height[j]>w[i]+height[to]){
                height[j]=w[i]+height[to];
                cnt[j]=cnt[to]+1;
                if(!st[j]){
                    que.push(j);
                    st[j]=1;
                }
                if(cnt[j]>n+3){
                    return false;
                }
            }
        }
    }
    return true;
}
int get_dist(int u,int v){
    return height[u]-height[v];
}
void dijkstra(int start){
    for(int i=1;i<=n;i++) {
        dist[i]=inf;st[i]=0;
    }
    priority_queue<pii,vector<pii>,greater<pii>> que;
    que.push({0,start});
    dist[start]=0;
    while(que.size()){
        pii to=que.top();que.pop();
        int u=to.second;
        if(st[u]) continue;
        st[u]=1;
        for(int i=q[u];i!=-1;i=ne[i]){
            int j=e[i];
            int len=dist[u]+w[i]+get_dist(u,j);
            if(dist[j]>len){
                dist[j]=len;
                que.push({dist[j],j});
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(i==start) continue;
        if(dist[i]>inf/2) dist[i]=non;
        else{
            dist[i]=dist[i]-height[start]+height[i];
        }
    }
    for(int i=1;i<=n;i++){
        ans+=i*dist[i];
    }
    cout<<ans<<'\n';
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        height[i]=inf;
    }
    for(int i=0;i<=n;i++){
        q[i]=-1;
    }
    for(int i=1;i<=m;i++){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    if(!spfa()){
        cout<<-1;
        return 0;
    }
    for(int i=1;i<=n;i++){
        dijkstra(i);
    }
    return 0;
}
```

---

## 大数快速阶乘

*文件: 大数快速阶乘.md*

n!%mod
```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=262144+10;typedef unsigned long long ll;
const int P=65536;const int SF=16;const int msk=65535;ll mod;ll PP;
typedef long double ld;const ld pi=acos(-1.0);
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
struct cmp
{
    ld r;ld v;
    friend cmp operator +(cmp a,cmp b){return (cmp){a.r+b.r,a.v+b.v};}
    friend cmp operator -(cmp a,cmp b){return (cmp){a.r-b.r,a.v-b.v};}
    friend cmp operator *(cmp a,cmp b){return (cmp){a.r*b.r-a.v*b.v,a.r*b.v+a.v*b.r};}
    void operator /=(const int& len){r/=len;v/=len;}
}rt[2][22][N],tr[N],tr1[N],tr2[N],tr3[N],tr4[N],tr5[N],tr6[N];
int rv[22][N];ll m13[N],m14[N],m23[N],m24[N];
inline void pre()
{
    for(int d=1;d<=18;d++)
        for(int i=1;i<(1<<d);i++)rv[d][i]=(rv[d][i>>1]>>1)|((i&1)<<(d-1));
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[0][d][i]=(cmp){cos(pi*i/t),sin(pi*i/t)};
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[1][d][i]=(cmp){cos(pi*i/t),-sin(pi*i/t)};
}inline void fft(cmp* a,int len,int d,int o)
{
    for(int i=1;i<len;i++)if(i<rv[d][i])swap(a[i],a[rv[d][i]]);cmp* w;int i;
    for(int k=1,j=1;k<len;k<<=1,j++)
        for(int s=0;s<len;s+=(k<<1))
            for(i=s,w=rt[o][j];i<s+k;i++,++w)
                {cmp a1=a[i+k]*(*w);a[i+k]=a[i]-a1;a[i]=a[i]+a1;}
    if(o)for(int i=0;i<len;i++)a[i]/=len;
}inline void dbdft(ll* a,int len,int d,cmp* op1,cmp* op2)
{
    for(int i=0;i<len;i++)tr[i]=(cmp){(ld)(a[i]>>SF),(ld)(a[i]&msk)};
    fft(tr,len,d,0);tr[len]=tr[0];
    for(cmp* p1=tr,*p2=tr+len,*p3=op1;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r+p2->r,p1->v-p2->v}*(cmp){0.5,0};
    for(cmp* p1=tr,*p2=tr+len,*p3=op2;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r-p2->r,p1->v+p2->v}*(cmp){0,-0.5};
}inline void dbidft(cmp* tr,int len,int d,ll* a,ll* b)
{
    fft(tr,len,d,1);
    for(int i=0;i<len;i++)a[i]=(ll)(tr[i].r+0.5)%mod;
    for(int i=0;i<len;i++)b[i]=(ll)(tr[i].v+0.5)%mod;
}inline void poly_mul(ll* a,ll* b,ll* c,int len,int d)//以上都是任意模数fft的板子 
{
    dbdft(a,len,d,tr1,tr2);dbdft(b,len,d,tr3,tr4);
    for(int i=0;i<len;i++)tr5[i]=tr1[i]*tr3[i]+(cmp){0,1}*tr2[i]*tr4[i];
    for(int i=0;i<len;i++)tr6[i]=tr2[i]*tr3[i]+(cmp){0,1}*tr1[i]*tr4[i];
    dbidft(tr5,len,d,m13,m24);dbidft(tr6,len,d,m23,m14);
    for(int i=0;i<len;i++)c[i]=m13[i]*PP%mod;
    for(int i=0;i<len;i++)(c[i]+=(m23[i]+m14[i])*P+m24[i])%=mod;
}namespace iter
{
    ll f[N];ll g[N];ll h[N];ll ifac[N];
    inline void ih()
    {
        ifac[0]=ifac[1]=1;
        for(int i=2;i<min((ll)N,mod);i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
        for(int i=1;i<min((ll)N,mod);i++)(ifac[i]*=ifac[i-1])%=mod;
    }inline void calch(ll del,int cur,ll* ip,ll* op)
    {
        int d=0;int len=1;while(len<=cur+cur+cur)len<<=1,d++;
        for(int i=0;i<=cur;i++)f[i]=ip[i]*ifac[i]%mod*ifac[cur-i]%mod;
        for(int i=cur-1;i>=0;i-=2)f[i]=(mod-f[i])%mod;
        for(int i=0;i<=cur+cur;i++)g[i]=po((del+mod-cur+i)%mod,mod-2); 
        for(int i=cur+1;i<len;i++)f[i]=0;for(int i=cur+cur+1;i<len;i++)g[i]=0;
        poly_mul(f,g,h,len,d);//卷积求出h' 
        ll xs=1;ll p1=del-cur;ll p2=del;
        for(int i=p1;i<=p2;i++)(xs*=i)%=mod;
        for(int i=0;i<=cur;i++,p1++,p2++)//双指针求出系数 
        {
            op[i]=h[i+cur]*xs%mod;
            (xs*=po(p1,mod-2))%=mod,(xs*=(p2+1))%=mod;
        }  
    }
}ll val[N];ll fv1[N];ll fv2[N];
inline void solve(int n)//倍增 
{
    int hb=0;for(int p=n;p;p>>=1)hb++;val[0]=1;
    for(int z=hb,cur=0;z>=0;z--)
    {
        if(cur!=0)//把d乘2 
        {
            iter::calch(cur+1,cur,val,fv1);
            for(int i=0;i<=cur;i++)val[cur+i+1]=fv1[i];val[cur<<1|1]=0;
            iter::calch(cur*po(n,mod-2)%mod,cur<<1,val,fv2);
            cur<<=1;for(int i=0;i<=cur;i++)(val[i]*=fv2[i])%=mod;
        }if((n>>z)&1)//把d加1 
        {
            for(int i=0;i<=cur;i++)(val[i]*=(ll)(n*i)+cur+1)%=mod;cur|=1;val[cur]=1;
            for(int i=1;i<=cur;i++)(val[cur]*=(ll)cur*n+i)%=mod;
        }
    }
}
int main()
{
    pre();int n;scanf("%d%lld",&n,&mod);//n!%mod
    iter::ih();
    int bl=sqrt(n);PP=(ll)P*P%mod;solve(bl);ll res=1;
    for(int i=0,id=0;;i+=bl,id++)//分块 
    {
        if((ll)i+bl>n){for(int j=i+1;j<=n;j++)(res*=j)%=mod;break;}
        (res*=val[id])%=mod;
    }printf("%lld",res);return 0;//拜拜程序~ 
}
```

---

## 快速取模机

*文件: 快速取模机.md*

```
struct Mod
{
    int m, p;
    void init(int pp) { m = ((__int128)1 << 64) / pp; p = pp; }
    int operator ()(int x)
    {
        return x - ((__int128(x) * m) >> 64) * p;
    }
} mod;
```

---

## 数位dp

*文件: 数位dp.md*

方法：先更具题意进行预处理，一般是排列组合
在更具每一位进行分类讨论
![[Pasted image 20240629202425.png]]
```
int f[N][N];//f[i][j]表示是预处理的
void init(){
    for(int i=0; i< N ;i ++)
        for(int j =0; j<= i ;j++)
            if(!j) f[i][j] =1;
            else f[i][j] =f[i-1][j] +f[i-1][j-1];
}
int dp(int n){
    if(   ) return 0; //特判
    vector<int> nums; //存放n在B进制下的每一位
    //把n在B进制下的每一位单独拿出来
    while(n) nums.push_back( n% B) , n/= B;
    int res = 0;//答案：[0,n]中共有多少个合法的数
    //last在数位dp中存的是：右边分支往下走的时候保存前面的信息 
    int last = 0; 
    //从最高位开始遍历每一位
    for(int i = nums.size()-1; i>= 0; i--){
        int x = nums[i]; //取当前位上的数
        if(   ){ //左右分支条件
            res += f[i][ K -last];//加上左分支
            if(   ){
                //右分支判断
               if(K - last -1 >= 0) res += f[i][K -last -1];
               //右分支走完
                break;
            }
            //右分支没走完
            else {
                last ++;
                //维护左分支
                if(   ) break;左分支超出题意
            }

        }
        //上面处理完了这棵树的**所有**左分支，就剩下最后一位最后一种右分支的情况
        if(i==0 && last == K) res++; 
    }
    return res;
}
```

---

## 旋转卡壳

*文件: 旋转卡壳.md*

```c++
#include<iostream>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
typedef pair<int,int> pii;
#define x first 
#define y second
pii operator-(pii a, pii b){
    return {a.x-b.x,a.y-b.y};
}
int operator*(pii a,pii b){
    return (a.x*b.y-a.y*b.x);
}
int jl(pii a,pii b){
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}
int cross(pii a,pii b,pii c){
    return (b-a)*(c-a);
}
int sta[100010];
int used[100010];
vector<pii> a;
int top;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        int j,k;cin>>j>>k;
        a.push_back({j,k});
    }
    sort(a.begin(),a.end());
    a.erase(unique(a.begin(),a.end()),a.end());
    int len=a.size()-1;
    for(int i=0;i<=len;i++){
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0) {
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    used[0]=0;
    for(int i=len-1;i>=0;i--){
        if(used[i]) continue;
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0) {
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    bool temp=true;
    for(int i=3;i<=top;i++){
        if(cross(a[sta[1]],a[sta[i-1]],a[sta[i]])==0)
            continue;
        temp=false;
        break;
    }
    if(temp){
        cout<<jl(a[0],a[len]);
        return 0;
    }
    int d=3;
    int ans=0;
    for(int i=2;i<=top;i++){
        double dq=cross(a[sta[i-1]],a[sta[i]],a[sta[d]]);
        while(cross(a[sta[i-1]],a[sta[i]],a[sta[d+1]])>=dq){
            d++;
            dq=cross(a[sta[i-1]],a[sta[i]],a[sta[d]]);
            if(d==top) d=1;
        }
        ans=max(ans,max(jl(a[sta[i-1]],a[sta[d]]),jl(a[sta[i]],a[sta[d]])));
    }
    // for(int i=1;i<=top;i++){
    //     cout<<a[sta[i]].first<<' '<<a[sta[i]].second<<'\n';
    // }
    cout<<ans;
    return 0;
}
```#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>

using namespace std;
typedef pair<int,int> pii;
#define x first
#define y second
const int N=1e5+10;
int sta[N],top;
int used[N];
pii operator-(pii a,pii b){
    return {a.x-b.x,a.y-b.y};
}
int operator*(pii a,pii b){
    return a.x*b.y-a.y*b.x;
}
int cross(pii a,pii b,pii c){
    return (b-a)*(c-a);
}
vector<pii> a;
int jl(pii a,pii b){
    int dx=a.x-b.x;
    int dy=a.y-b.y;
    return dx*dx+dy*dy;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        int j,k;cin>>j>>k;
        a.push_back({j,k});
    }
    sort(a.begin(),a.end());
    a.erase(unique(a.begin(),a.end()),a.end());
    int len=a.size();
    for(int i=0;i<len;i++){
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0){
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    used[0]=0;
    for(int i=len-2;i>=0;i--){
        if(used[i]) continue;
        while(top>=2&&cross(a[sta[top-1]],a[sta[top]],a[i])<0){
            used[sta[top]]=0;
            top--;
        }
        sta[++top]=i;
        used[i]=1;
    }
    bool temp=true;
    for(int i=3;i<top;i++){
        if(cross(a[sta[1]],a[sta[i-1]],a[sta[i]])==0) continue;
        temp=false;
        break;//防止同一条直线
    }
    if(temp){
        cout<<jl(a[0],a[a.size()-1]);
        return 0;
    }
    int d=1;
    int ar=cross(a[sta[1]],a[sta[2]],a[sta[1]]);
    int ans=0;
    for(int i=2;i<top;i++){
        if(ar<=cross(a[sta[1]],a[sta[2]],a[sta[d]])){
            ar=cross(a[sta[1]],a[sta[2]],a[sta[d]]);
            d=i;
        }
    }
    ans=max(ans,max(jl(a[sta[1]],a[sta[d]]),jl(a[sta[2]],a[sta[d]])));
    for(int i=3;i<=top;i++){
        double dq=cross(a[sta[i-1]],a[sta[i]],a[sta[d]]);
        while(cross(a[sta[i-1]],a[sta[i]],a[sta[d+1]])>=dq){
            d++;
            dq=cross(a[sta[i-1]],a[sta[i]],a[sta[d]]);
            if(d==top) d=1;
        }
        ans=max(ans,max(jl(a[sta[i-1]],a[sta[d]]),jl(a[sta[i]],a[sta[d]])));
    }
    cout<<ans;
    return 0;
}

```

---

## 无向图的点双联通分量

*文件: 无向图的点双联通分量.md*

~~~c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N=5e5+10,M=4e6+10;

int q[N],e[M],ne[M],idx;
int n,m;
int dfn[N],low[N],cnt;
int sta[N],top;
vector<int> ans[N];
int num;

void add(int a,int b){
    e[idx]=b;ne[idx]=q[a];q[a]=idx++;
}

void tarjan(int u,int fa){
    int son=0;
    dfn[u]=low[u]=++cnt;
    sta[++top]=u;
    for(int i=q[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(!dfn[j]){
            tarjan(j,u);
            son++;
            low[u]=min(low[j],low[u]);
            if(low[j]>=dfn[u]){
                num++;
                while(1){
                    int to=sta[top];
                    ans[num].push_back(to);
                    top--;
                    if(to==j) break;
                }
                ans[num].push_back(u);
            }
        }
        else if(j!=fa){
            low[u]=min(low[u],dfn[j]);
        }
    }
    if(fa==0&&son==0) ans[++num].push_back(u);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=0;i<=n;i++) q[i]=-1;
    for(int i=1;i<=m;i++){
        int a,b;cin>>a>>b;
        add(a,b);add(b,a);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i,0);
    }
    cout<<num<<'\n';
    for(int i=1;i<=num;i++) sort(ans[i].begin(),ans[i].end());
    sort(ans+1,ans+1+num);
    for(int i=1;i<=num;i++){
        cout<<ans[i].size()<<' ';
        for(int u:ans[i]){
            cout<<u<<' ';
        }
        cout<<'\n';
    }
    return 0;
}
~~~

---

## 无向图的边双联通分量

*文件: 无向图的边双联通分量.md*

``` C++
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
const int N=5e5+10,M=4e6+10;

int q[N],e[M],ne[M],idx;
int used[M*2];
int n,m;
int dfn[N],low[N],cnt;
int sta[N],top;
vector<int> ans[N];
int num;

void add(int a,int b){
    e[idx]=b;ne[idx]=q[a];q[a]=idx++;
}

void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    sta[++top]=u;
    for(int i=q[u];i!=-1;i=ne[i]){
        if(used[i]) continue;
        int j=e[i];
        used[i]=1;used[i^1]=1;
        if(!dfn[j]){
            tarjan(j);
            low[u]=min(low[j],low[u]);
        }
        else{
            low[u]=min(low[u],dfn[j]);
        }
    }
    if(dfn[u]==low[u]){
        num++;
        while(1){
            int to=sta[top];top--;
            ans[num].push_back(to);
            if(to==u) break;
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=0;i<=n;i++) q[i]=-1;
    for(int i=1;i<=m;i++){
        int a,b;cin>>a>>b;
        add(a,b);add(b,a);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
    cout<<num<<'\n';
    for(int i=1;i<=num;i++) sort(ans[i].begin(),ans[i].end());
    sort(ans+1,ans+1+num);
    for(int i=1;i<=num;i++){
        cout<<ans[i].size()<<' ';
        for(int u:ans[i]){
            cout<<u<<' ';
        }
        cout<<'\n';
    }
    return 0;
}
```

---

## 时间复杂度

*文件: 时间复杂度.md*

![[Pasted image 20241206153516.png]]

---

## 最长上升子序列

*文件: 最长上升子序列.md*

```
const int N = 1010;

int n;
int w[N], f[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> w[i];

    int mx = 1;    // 找出所计算的f[i]之中的最大值，边算边找
    for (int i = 0; i < n; i++) {
        f[i] = 1;    // 设f[i]默认为1，找不到前面数字小于自己的时候就为1
        for (int j = 0; j < i; j++) {
            if (w[i] > w[j]) f[i] = max(f[i], f[j] + 1);    // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1
        }
        mx = max(mx, f[i]);
    }

    cout << mx << endl;
    return 0;
}

```

---

## 有向图的强连通分量

*文件: 有向图的强连通分量.md*

### tarjan

#### 有向图的强连通分量

这份代码实质上实在进行强连通分量缩点，缩点之后为有向无环图
ans[1] ~ ans[num] 存所有的强联通分量，单点则单点存放，按照从小到大的顺序

~~~c++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
#define int long long
typedef pair<int, int> pii;
typedef pair<pii,int> piii;
const int mod = 998244353;
const int inf = 1e18 + 7;
const int N = 2e4 + 10,M=2e5+10;
// #define l first
// #define r second
int n,m;
vector<int> adj[N];
int low[N],dfn[N],cnt;
vector<int> ans[N];
int num;
int sta[N],top;
int st[N];
void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    st[u]=1;
    sta[++top]=u;
    for(int j:adj[u]){
        if(!dfn[j]){
            tarjan(j);
            low[u]=min(low[u],low[j]);
        }
        else if(st[j]){
            low[u]=min(low[u],low[j]);
        }
    }
    if(dfn[u]==low[u]){
        num++;
        while(1){
            int to=sta[top];
            ans[num].push_back(to);
            top--;
            st[to]=false;
            if(to==u) break;
        }
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int a,b;cin>>a>>b;
        adj[a].push_back(b);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
    for(int i=1;i<=num;i++){
        sort(ans[i].begin(),ans[i].end());
    }
    sort(ans+1,ans+1+num);
    cout<<num<<'\n';
    for(int i=1;i<=n;i++){
        for(int j:ans[i]){
            cout<<j<<" ";
        }
        cout<<'\n';
    }
    return 0;
}
```
~~~


---

## 欧拉定理与乘法逆元

*文件: 欧拉定理与乘法逆元.md*

![[Pasted image 20240629204529.png]]
![[Pasted image 20240629210052.png]]
## 欧拉定理
![[Pasted image 20240629210151.png]]

```
int main()//求n的欧拉函数个数，如果n为质数，其欧拉函数为n-1
{
    int n;
    cin>>n;
    while(n--)
    {
        int a,res;
        cin>>a;
        res = a;
        for(int i=2;i<=a/i;i++)
        {
            if(a%i==0)
            {
                while(a%i==0)
                    a/=i;
                res = res / i*(i-1);
            }
        }
        if(a>1) res = res /a*(a-1);
        cout<<res<<endl;
    }
    return 0;
}
```
### 当n为质数时，可以用快速幂求逆元：
###### a / b ≡ a * x (mod n)
###### 两边同乘b可得 a ≡ a * b * x (mod n)
###### 即 1 ≡ b * x (mod n)
###### 同 b * x ≡ 1 (mod n)
###### 由费马小定理可知，当n为质数时
###### b ^ (n - 1) ≡ 1 (mod n)  （因为n为质数，n的欧拉函数为n-1)
###### 拆一个b出来可得 b * b ^ (n - 2) ≡ 1 (mod n)
###### 故当n为质数时，b的乘法逆元 x = b ^ (n - 2)

### 当n不是质数时，可以用扩展欧几里得算法求逆元：
###### a有逆元的充要条件是a与p互质，所以gcd(a, p) = 1
###### 假设a的逆元为x，那么有a * x ≡ 1 (mod p)
###### 等价：ax + py = 1
###### exgcd(a, p, x, y)

![[Pasted image 20240629210427.png]]
```
typedef long long LL;
int exgcd(int a, int b, int &x, int &y)//指针引用
{
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int a, p, x, y;
    cin >>  a >> p;  // if (a < p) swap(a, p);
    int d = exgcd(a, p, x, y);
    if (d == 1) cout << ((LL)x + p) % p << endl;//保证x是正数 d为最大公因数
    return 0;
}

```

---

## 欧拉筛质数（线性筛）

*文件: 欧拉筛质数（线性筛）.md*

```
void get_primes(){
    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定
    for(int i=2;i<=n;i++){
        if(!st[i]) {
	        primes[cnt++]=i;
	        st[i]=i;//质数最小质因子是自己
	    }
        for(int j=0;primes[j]<=n/i;j++){//primes[j]<=n/i:
            st[primes[j]*i]=primes[j];//用最小质因子去筛合数,存最小的质数
            if(i%primes[j]==0) break;
        }
    }
}
```

---

## 求组合数

*文件: 求组合数.md*

### 小数据直接循环
```
for(int i=0; i< N ;i ++)
    for(int j =0; j<= i ;j++)
        if(!j) f[i][j] =1;
        else f[i][j] =f[i-1][j] +f[i-1][j-1];
```
## 大数据用卢卡斯定理
```
#include<iostream>
#include<algorithm>

using namespace std;

typedef long long LL;

int qmi(int a,int k,int p)
{
    int res = 1;
    while(k)
    {
        if(k&1)res = (LL)res*a%p;
        a = (LL)a*a%p;
        k>>=1;
    }
    return res;
}

int C(int a,int b,int p)//自变量类型int
{
    if(b>a)return 0;//漏了边界条件
    int res = 1;
    // a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项
    for(int i=1,j=a;i<=b;i++,j--)//i<=b而不是<
    {
        res = (LL)res*j%p;
        res = (LL)res*qmi(i,p-2,p)%p;
    }
    return res;
}
//对公式敲
int lucas(LL a,LL b,int p)
{
    if(a<p && b<p)return C(a,b,p);//lucas递归终点是C_{bk}^{ak}
    return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是<p的,所以可以用C(),但a/p后不一定<p 所以用lucas继续递归
}

int main()
{
    LL a,b;
    int p;
    cin >> a >> b >> p;
    cout << lucas(a,b,p) << endl;
    return 0;
}
```

---

## 笛卡尔树

*文件: 笛卡尔树.md*

**[笛卡尔树](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91&zhida_source=entity)**（Cartesian Tree）是一种特殊的二叉树，它可以从一个给定的序列构建而成，并且同时满足以下两个性质：

1. **[二叉搜索树](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&zhida_source=entity)（BST）性质**：对于树中的每一个节点，其左子树中的所有节点的值都小于该节点的值；其右子树中的所有节点的值都大于该节点的值。这保证了树在中序遍历时会按照输入序列的顺序访问元素。
2. **[堆性质](https://zhida.zhihu.com/search?content_id=248726168&content_type=Article&match_order=1&q=%E5%A0%86%E6%80%A7%E8%B4%A8&zhida_source=entity)**：如果我们将笛卡尔树看作是一个最大堆或最小堆，则对于每个节点来说，它的值要么不小于（最大堆）或者不大于（最小堆）其子节点的值。具体采用哪种堆取决于应用场景。
```c++
for(int i=1;i<=n;i++){

        int k=top;

        while(k>0&&a[sta[k]]>a[i]) k--;

        if(k) rs[sta[k]]=i;

        if(k<top) ls[i]=sta[k+1];

        sta[++k]=i;

        top=k;

    }
```

---

## 线段树

*文件: 线段树.md*

```
#include <iostream>
using namespace std;
const int N = 3e5 + 5;
struct node
{
    int l, r;
    int v;
} tr[4*N];
void pushdown(int u){
    if(  tr[u] ){
        {
            tr[u<<1]=;
            tr[u<<1|1]=;
        }
    }
}
void pushup(node &root, node l, node r)
{

}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    tr[u].l = l, tr[u].r = r, tr[u].v = ;
    if (l == r)
    {
		 tr[u].v =
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}
node query(int u, int l, int r)
{
    if(l>r) {
        node re={0,0,0};
        return re;
    }
    if (tr[u].l >= l && tr[u].r <= r)
        return tr[u];
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    node ans = {0, 0, 0};
    if (mid < l)
    {
        node lef=query(u << 1|1, l, r);
        pushup(u);
        return lef;
    }
    if (mid >=r )
    {
        node rig=query(u << 1 , l, r);
        pushup(u);
        return rig;
    }
    node left = query(u << 1, l, r);
    node right = query(u << 1 | 1, l, r);
    pushup(u);
    pushup(ans, left, right);
    return ans;
}
void modify(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        tr[u]=;
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (mid >= l)
        modify(u << 1, l, r);
    if (mid < r)
        modify(u << 1 | 1, l, r);
    pushup(u);
}
int main()
{
    cin >> n >> q;
    build(1, 1, n);
    
    while (q--)
    {
        int op, l, r;
        cin >> op >> l >> r;
        if (op == 1)
        {
            modify(1, l, r);
        }
        else
        {
            node ui = query(1, l, r);
            cout << min(ui.kt0, ui.kt1) << '\n';
        }
    }
    return 0;

}
```

---

## 背包

*文件: 背包.md*

## 1、01背包问题
定义：物品只有一个，只能取或者不取。
```
**版本1 二维**

（1）状态f[i][j]定义：前i个物品，背包容量j下的最优解（最大价值）：

当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0] = 0开始决策，有 N件物品，则需要 N次决 策，每一次对第 i件物品的决策，状态f[i][j]不断由之前的状态更新而来。

（2）当前背包容量不够（j < v[i]），没得选，因此前 i个物品最优解即为前 i−1个物品最优解：

对应代码：f[i][j] = f[i - 1][j]。

（3）当前背包容量够，可以选，因此需要决策选与不选第 i个物品：

选：f[i][j] = f[i - 1][j - v[i]] + w[i]。

不选：f[i][j] = f[i - 1][j] 。

我们的决策是如何取到最大价值，因此以上两种情况取 max()

for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i])
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else   
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }
**版本2 一维**
将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。
为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。
（1）状态f[j]定义：N件物品，背包容量j下的最优解。
（2）注意枚举背包容量j必须从m开始。
（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。
状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] )。
实际上，只有当枚举的背包容量 j>= v[i] 时才会更新状态，因此我们可以修改循环终止条件进一步优化。
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--) 
        f[j] = max(f[j], f[j - v[i]] + w[i]);
}
```
## 2、完全背包问题
定义：物品有无限个，可以限取得
```
**版本一：二维**
每种物品从0到最多尝试全部取一遍

for(int j = 0 ; j<=m ;j++)
    {
        for(int k = 0 ; k*v[i]<=j ; k++) //取k个物品
            f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
}
f[i , j ] = max( f[i-1,j]   ,  f[i-1,j-v]+w ,  
   f[i-1,j-2*v]+2*w ,    f[i-1,j-3*v]+3*w , .....)

f[i , j-v]= max( f[i-1,j-v] ,  f[i-1,j-2*v] + w , 
   f[i-1,j-3*v]+2*w ,    .....)
   
由上两式，可得出如下递推关系：
f[i][j]=max(f[i,j-v]+w , f[i-1][j])
有了上面的关系，那么其实k循环可以不要了，核心代码优化成这样：

for(int i = 1 ; i <=n ;i++)
	for(int j = 0 ; j <=m ;j++)
	{
           f[i][j] = f[i-1][j];
           if(j-v[i]>=0)
              f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
	}

**版本二：一维**

用小的更新大的

for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)//注意了，这里的j是从小到大枚举，和01背包不一样
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
	}
```
  
## 3、多重背包问题

定义：每个物品有数量限制，每一个物品可以任意选。
```
for(int i = 1;i <= n;i ++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1; // 组别里面的个数
        while(k<=s)
        {
            cnt ++ ; //组别先增加
            v[cnt] = a * k ; //整体体积
            w[cnt] = b * k; // 整体价值
            s -= k; // s要减小
            k *= 2; // 组别里的个数增加
        }
        //剩余的一组
        if(s>0)
        {
            cnt ++ ;
            v[cnt] = a*s;
            w[cnt] = b*s;
        }
    }
    n = cnt ; //枚举次数正式由个数变成组别数
    //01背包一维优化  剩下做法和01背包一样
    for(int i = 1;i <= n ;i ++)
        for(int j = m ;j >= v[i];j --)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
```
      

---

## 高斯消元

*文件: 高斯消元.md*

```cpp
#include<iostream>

#include<cmath>

using namespace std;

double x[200][200];

double eps=1e-9;

double ans[200];

int main(){

    ios::sync_with_stdio(false);

    cin.tie(0);cout.tie(0);

    int n;cin>>n;

    for(int i=1;i<=n;i++){

        for(int j=1;j<=n+1;j++){

            cin>>x[i][j];

        }

    }

    for(int i=1;i<n;i++){//遍历每一位

        int t=i;

        for(int j=i;j<=n;j++){//找到当前最大位

            if(x[i][j]>x[i][t]){

                t=j;

            }

        }//x[列][行]

        if(fabs(x[i][t])<eps){

            cout<<"No Solution";

            return 0;

        }

        for(int j=1;j<=n+1;j++){

            swap(x[j][i],x[j][t]);

        }

        for(int j=i+1;j<=n;j++){

            double bs=x[i][j]/x[i][i];

            for(int k=i;k<=n+1;k++){

                x[k][j]-=bs*x[k][i];

            }

        }

    }

    ans[n]=x[n+1][n];

    for(int i=n-1;i>=1;i--){

        ans[i]=x[n+1][i];

        for(int j=n;j>i;j--){

            ans[i]-=x[j][i]*ans[j];

        }

    }

    for(int i=1;i<=n;i++){

        printf("%.2lf\n",ans[i]);

    }

    return 0;

}
```
